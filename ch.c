/* ch.c.
auteur:
date:
problèmes connus:

  */

#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int delimCounter(char *string, const char *delim);

void ezParser(char *srcString, char *dstArray[], size_t dstSize, const char *delim);

int executeCommand(char *args[], int argsSize);

int main (void){
    fprintf (stdout, "%% ");

    /* ¡REMPLIR-ICI! : Lire les commandes de l'utilisateur et les exécuter. */

    const char s[2] = " ";
    const char eq[2] = "=";
    const char semiC[2] = ";";
    int exitValue = 1;
        
    while(exitValue) {
        //shell loops until "exit" is entered
        char *line = NULL;  //ugly variable declarations
        //char *cmd = NULL; as of yet unused
        //char *arg = NULL; as of yet unused
        size_t length = 0;
        ssize_t read;
        
        fprintf (stdout, "our-shell> ");

        // Read input from keyboard
        read = getline(&line, &length, stdin);
        
        //eof, generated by CRTL+D in Unix and CRTL+Z in Windows makes getline 
        //and getchar return -1, thus we check for it to exit the shell
        if (read == -1){ exitValue = 0;}
        
        // Remove end of line character
        size_t len = strlen(line);
        if(len > 0 && line[len-1] == '\n') {
          line[--len] = '\0';
        }

        
        //To avoid errors if the users types ENTER without entering a command
        if(strcmp(line, "\0") == 0){
        
        }else if(strchr(line, '=')) {
            // 2. Gestion des variables
            char *var = strtok(line, eq);
            char *val = strtok(NULL, eq);
            setenv(var, val, 0);
            
        }else if(strstr(line, "for ") == line){
            //Handling for loops
            if(strstr(line, "; done") == line+(len-6)){
                
                //initialization and body of for loop in two strings
                //to be parsed differently
                char *init = strtok(line, semiC);
                char *body = strtok(NULL, "");
                
                //Parse arguments of for loop initialization
                int spaces = delimCounter(init, s);
                char *initArgs[spaces+1];
                ezParser(init, initArgs, sizeof initArgs, s);
                int initLen = sizeof(initArgs)/sizeof(initArgs[0]);
                                    
                // Parse arguments for loop body
                int commands = delimCounter(body, semiC);
                char *bodyArgs[commands+2];
                ezParser(body, bodyArgs, sizeof bodyArgs, semiC);
                                    
                //in the sentence "for i in A B C ..." the first value is in
                //the 4th position so we start at 3
                for(int i = 3; i < initLen-1; i++){
                    //Assign value to the variable in the environment
                    setenv(initArgs[1], initArgs[i], 0);
                    
                    for(int j = 0; j < commands; j++){
                                                       
                        //Parse arguments of one command within loop body
                        int spcs = delimCounter(bodyArgs[j], s);
                        char copy[strlen(bodyArgs[j])];
                        strcpy(copy, bodyArgs[j]);
                        char *bodyCmd[spcs];
                        ezParser(copy, bodyCmd, spcs, s);
                                                   
                        //the first command in the loop should have a "do"
                        //so we have to detect it and get rid of it
                        if(j == 0){
                            if(strcmp(bodyCmd[0], "do") != 0){
                                i = initLen;
                                fprintf(stderr, "do statement missing\n");
                            }else{
                                char *fstCmd[spcs-1];
                                for(int k = 1; k < spcs; k++){
                                    fstCmd[k-1] = bodyCmd[k];
                                }
                                
                                executeCommand(fstCmd, 
                                    sizeof(fstCmd)/sizeof(fstCmd[0]));
                            }
                        }else {
                            executeCommand(bodyCmd, 
                                sizeof(bodyCmd)/sizeof(bodyCmd[0]));
                        }
                        
                    }
                    unsetenv(initArgs[1]);
                }
            
            }else {fprintf (stderr, "done statement missing\n");}                   
                
            //Haven't found a more ingenious/efficient way to predict number of 
            //tokens in the line aside from counting delimiters...yet 
                        
        }else {
                       
            int spaces = delimCounter(line, s);
            
            // Parse arguments
            char *args[spaces+2]; // +1 word than space, +1 for NULL at the end
            ezParser(line, args, spaces+2, s);
                          
            exitValue = executeCommand(args, spaces+2);
        }
    }
    fprintf (stdout, "Bye!\n");
    exit (0);
}

int delimCounter(char *string, const char *delim){
    //Counts number of delimiters in a string. Useful for parsing all the things
    size_t len  = strlen(string);
    int i, separators;
    for (i=0, separators=0; i < len; i++) {
    separators += (string[i] == *delim);
    }
    return separators;
}

void ezParser(char *srcString, char *dstArray[], size_t dstSize, const char *delim){
    //tokenizes a string to a destination array according to a delimiter
    int j=0;
    
    char *token = strtok(srcString, delim);
    while(token) {
        // Check if token is a variable
        if(token[0] == '$') {
          token = getenv(strtok(token, "$"));
        }
        dstArray[j] = token;
        token = strtok(NULL, delim);
        j++;
    }
    dstArray[j] = NULL;

}

int executeCommand(char *args[], int argsSize){
    
    //1. Crée un processus qui exécute la commande
    pid_t  pid;
    pid = fork();

    char *rest[argsSize];
    char *separator = NULL;
    // determine the separator type and parse first command
    int i = 0, offset = 0;
    while(args[i]) {
    	if(!separator && (strcmp(args[i], "&&") == 0 || strcmp(args[i], "||") == 0)) {
		separator = args[i];
		offset = i+1;
		args[i] = NULL;
	} else if(offset != 0) {
		rest[i-offset] = args[i];
	}
	i++;
    }
    if(offset > 0) {
	rest[i-offset] = NULL;
    }

    if (pid < 0) {
        fprintf (stderr, "Fork failed");
    }
    if (pid == 0) {
        //Child process
        if(strcmp(args[0], "cd") == 0){
            //so that the || and && operators can be used on the cd command
            chdir(args[1]);
        }else if(strcmp(args[0], "exit") != 0){execvp(args[0], args);}
	    perror(args[0]);
	    exit(1);
    }
    else {
        //Parent process
        
        //because cd and exit need to affect the parent, ie: the shell
        if(strcmp(args[0], "cd") == 0){
            chdir(args[1]);
        }else if(strcmp(args[0], "exit") == 0){ return 0;}

	int waitError;
        wait(&waitError);

	// && and || logic
	while(separator) {
		if(strcmp(separator, "||") == 0 && waitError) {
			separator = NULL;
			executeCommand(rest, argsSize-offset);
		} else if(strcmp(separator, "&&") == 0 && !waitError) {
			separator = NULL;
			executeCommand(rest, argsSize-offset);
		} else {
			//Get next separator and command
			separator = NULL;
			int j = 0, nextOffset = 0;
			while(rest[j]) {
				if(!separator &&
					(strcmp(rest[j], "&&") == 0 || strcmp(rest[j], "||") == 0) ) {
					separator = rest[j];
					nextOffset = j+1;
					offset += nextOffset;
				} else if (nextOffset > 0) {
					rest[j-nextOffset] = rest[j];
				}
				j++;
			}
			if(nextOffset > 0) {
				rest[j-nextOffset] = NULL;
			}
		}
	}
        fprintf (stdout, "Parent finished\n");
    }
    return 1;
}

int executeCommandBu(char *args[], int argsSize){
    
    //1. Crée un processus qui exécute la commande
    pid_t  pid;
    pid = fork();

    char *firstcmd[argsSize], *rest[argsSize];
    char *separator = NULL;
    // 1. determine the separator type
    int i = 0, offset = 0;
    while(args[i]) {
    	if(!separator && (strcmp(args[i], "&&") == 0 || strcmp(args[i], "||") == 0)) {
		separator = args[i];
		offset = i+1;
		args[i] = NULL;
	} else if(offset != 0) {
		rest[i-offset] = args[i];
	}
	i++;
    }
    if(offset > 0) {
	rest[i-offset] = NULL;
    }
    // 2. parse first command/rest
    
        
    if (pid < 0) {
        fprintf (stderr, "Fork failed");
    }
    if (pid == 0) {
        //Child process
        if(strcmp(args[0], "cd") == 0){
            //so that the || and && operators can be used on the cd command
            chdir(args[1]);
        }else if(strcmp(args[0], "exit") != 0){execvp(args[0], args);}
	    perror(args[0]);
	    exit(1);
    }
    else {
        //Parent process
        
        //because cd and exit need to affect the parent, ie: the shell
        if(strcmp(args[0], "cd") == 0){
            chdir(args[1]);
        }else if(strcmp(args[0], "exit") == 0){ return 0;}
	    int waitError;
        wait(&waitError);

	    if(separator && strcmp(separator, "||") == 0 && waitError) {
		    executeCommand(rest, argsSize-offset);
	    }
	    if(separator && strcmp(separator, "&&") == 0 && !waitError) {
		    executeCommand(rest, argsSize-offset);
	    }
            fprintf (stdout, "Parent finished\n");
        }
    
    return 1;
}

void parseSubcommand(char *args[], int argsSize, char *firstcmd[], char *rest[]) {
	int isFirst = 1;
	int firstcmdSize = 0;
	for(int i=0; i<argsSize; i++) {
		if(strcmp(args[i], "||") == 0 || strcmp(args[i], "&&") == 0) {
			isFirst = 0;
			firstcmdSize = i;
		}
		if(isFirst) {
			firstcmd[i] = args[i];
		}
		else {
			rest[i-(firstcmdSize+1)] = args[i];
		}
	}
}
