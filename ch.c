/* ch.c.
auteur:
date:
problèmes connus:

  */

#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int delimCounter(char *string, const char *delim);

void ezParser(char *srcString, char *dstArray[], size_t dstSize, const char *delim);

void executeCommand(char *args[], int argsSize);

int main (void){
    fprintf (stdout, "%% ");

    /* ¡REMPLIR-ICI! : Lire les commandes de l'utilisateur et les exécuter. */

    const char s[2] = " ";
    const char eq[2] = "=";
    const char semiC[2] = ";";
        
    while(1) { //TODO : end of loop condition
        //usually, "exit" is the command used to kill most shells, so we could use
        //that as the end of loop condition; if the command is exit, then we break
        //the while loop
        char *line = NULL;  //ugly variable declarations
        char *cmd = NULL;
        char *arg = NULL;
        size_t length = 0;
        ssize_t read;
        
        fprintf (stdout, "our-shell> ");

        // Read input from keyboard
        read = getline(&line, &length, stdin);
        
        //eof, generated by CRTL+D in Unix and CRTL+Z in Windows makes getline 
        //and getchar return -1, thus we check for it to exit the shell
        if (read == -1){ break;}
        
        // Remove end of line character
        size_t len = strlen(line);
        if(len > 0 && line[len-1] == '\n') {
          line[--len] = '\0';
        }

        // Check if is a variable declaration
        char *pt = strchr(line, '=');
        
        if(pt) {
            // 2. Gestion des variables
            char *var = strtok(line, eq);
            char *val = strtok(NULL, eq);
            setenv(var, val, 0);
            
        }else if(strstr(line, "for")) {
            //Handling for loops
            if(strstr(line, "do")){
                
                if(strstr(line, "done")){
                    //initialization and body of for loop in two strings
                    //to be parsed differently
                    char *init = strtok(line, semiC);
                    char *body = strtok(NULL, "");
                    
                    //Parse arguments of for loop initialization
                    int spaces = delimCounter(init, s);
                    char *initArgs[spaces+1];
                    ezParser(init, initArgs, sizeof initArgs, s);
                                        
                    // Parse arguments for loop body
                    int commands = delimCounter(body, semiC);
                    char *bodyArgs[commands+2];
                    ezParser(body, bodyArgs, sizeof bodyArgs, semiC);
                    
                    //in the sentence "for i in A B C ..." the first value is in
                    //the 4th position so we start at 3
                    for(int i = 3; i < spaces; i++){
                           
                        for(int j = 0; j < commands; j++){
                            
                            pid_t  pid;
                            pid = fork();
                                    
                            if (pid < 0) {
                                fprintf (stderr, "Fork failed");
                            }
                            if (pid == 0) {
                                //Child process
                                //Assign a value to the variable in the environment
                                setenv(initArgs[1], initArgs[i], 0);
                                
                                //Parse arguments of one command within loop body
                                int spaces = delimCounter(bodyArgs[j], s);
                                char *args[spaces];
                                ezParser(bodyArgs[j], args, spaces, s);
                                
                                //the first command in the loop has a "do"
                                //in front of it so we have to get rid of it
                                //before throwing it into execvp
                                if(strstr(args[0], "do")){
                                    
                                    char *fstArgs[spaces-1];
                                    for(int k = 1; k < spaces; k++){
                                        fstArgs[k-1] = args[k];
                                    }
                                    
                                    execvp(fstArgs[0], fstArgs);
                                }else {execvp(args[0], args);}
                                    
                            }else {
                                //Parent process
                                wait(NULL);
                                fprintf (stdout, "Parent finished\n");
                            }
                            
                        }
                    }
                    
                    
                }else {
                    fprintf (stderr, "Loop body is not closed with \"done\"\n");
                }
            }else {fprintf (stderr, "\"Do\" statement is missing\n");}
            //Haven't found a more ingenious/efficient way to predict number of 
            //tokens in the line aside from counting delimiters...yet 
                        
        }else {
                       
            int spaces = delimCounter(line, s);
            
            // Parse arguments
            char *args[spaces+2]; // +1 word than space, +1 for NULL at the end
            ezParser(line, args, sizeof args, s);
                          
            //Special cases for exit and cd since we want them to affect the process
            //that calls them instead of having them affect its child
            if(strcmp(args[0], "exit") == 0){
                break;
            }else if(strcmp(args[0], "cd") == 0){
                int ret = chdir(args[1]);
                if(ret != 0){fprintf (stdout, "invalid path\n");}         
            }
            else{
              
                executeCommand(args, spaces+2);                              
            }
 
            //TODO: 4. && et ||
            //chercher le && ou ||, puis tokenize?

        }
    }
    fprintf (stdout, "Bye!\n");
    exit (0);
}

int delimCounter(char *string, const char *delim){
    //Counts number of delimiters in a string. Useful for parsing all the things
    size_t len  = strlen(string);
    int i, separators;
    for (i=0, separators=0; i < len; i++) {
    separators += (string[i] == *delim);
    }
    return separators;
}

void ezParser(char *srcString, char *dstArray[], size_t dstSize, const char *delim){
    //tokenizes a string to a specified destination array according to a 
    //specified delimiter
    int j=0;
    
    char *token = strtok(srcString, delim);
    while(token) {
        // Check if token is a variable
        if(token[0] == '$') {
          token = getenv(strtok(token, "$"));
        }
        dstArray[j] = token;
        token = strtok(NULL, delim);
        j++;
    }
    dstArray[j] = NULL;

}

void executeCommand(char *args[], int argsSize){
    
    //1. Crée un processus qui exécute la commande
    pid_t  pid;
    pid = fork();

    char *firstcmd[argsSize], *rest[argsSize];
    char *separator = NULL;
    // 1. determine the separator type
    int i = 0, offset = 0;
    while(args[i]) {
    	if(!separator && (strcmp(args[i], "&&") == 0 || strcmp(args[i], "||") == 0)) {
		separator = args[i];
		offset = i+1;
		args[i] = NULL;
	} else if(offset != 0) {
		rest[i-offset] = args[i];
	}
	i++;
    }
    if(offset > 0) {
	rest[i-offset] = NULL;
    }
    // 2. parse first command/rest

    if (pid < 0) {
        fprintf (stderr, "Fork failed");
    }
    if (pid == 0) {
        //Child process
        execvp(args[0], args);
	perror(args[0]);
	exit(1);
    }
    else {
        //Parent process
	int waitError;
        wait(&waitError);

	if(separator && strcmp(separator, "||") == 0 && waitError) {
		executeCommand(rest, argsSize-offset);
	}
	if(separator && strcmp(separator, "&&") == 0 && !waitError) {
		executeCommand(rest, argsSize-offset);
	}
        fprintf (stdout, "Parent finished\n");
    }
}

void parseSubcommand(char *args[], int argsSize, char *firstcmd[], char *rest[]) {
	int isFirst = 1;
	int firstcmdSize = 0;
	for(int i=0; i<argsSize; i++) {
		if(strcmp(args[i], "||") == 0 || strcmp(args[i], "&&") == 0) {
			isFirst = 0;
			firstcmdSize = i;
		}
		if(isFirst) {
			firstcmd[i] = args[i];
		}
		else {
			rest[i-(firstcmdSize+1)] = args[i];
		}
	}
}
